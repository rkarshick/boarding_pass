<!-- FILE: index.html  (BoardPass Kiosk / GitHub Pages repo) -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>BoardPass Printer ‚Äî Kiosk</title>
<style>
  :root{
    --border:#ddd; --ink:#0b0b0b; --muted:#666; --card:#f7f7f7; --ok:#0a7a2f; --warn:#b45a00; --err:#b00020;
    --shadow: 0 2px 14px rgba(0,0,0,.06);
  }
  html,body{ margin:0; padding:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#fff; color:var(--ink); }
  main{ padding:16px; max-width:1200px; margin:auto; }
  h1{ margin: 10px 0 4px; font-size: 26px; }
  h2{ margin: 8px 0 10px; font-size: 18px; color:#111; }
  .sub{ color:var(--muted); margin:0 0 14px; }
  .banner{
    padding:10px 12px; border-radius:10px; border:1px solid var(--border);
    background:#f5f7ff; box-shadow: var(--shadow); font-size:14px; word-break:break-word;
  }
  .banner.ok{ background:#eef8d6; border-color:#cde59e; }
  .banner.warn{ background:#fff4e5; border-color:#ffd59a; }
  .banner.err{ background:#ffe8ea; border-color:#ffb7bf; }
  #stage{ position:relative; margin-top:12px; }
  #cam, #preview{
    width:100%; max-height:56vh; object-fit:cover; border-radius:14px; background:#000; display:block;
    border:1px solid rgba(0,0,0,.08);
  }
  #preview{ display:none; object-fit:contain; background:#000; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0; }
  button{
    padding:10px 14px; border-radius:12px; border:1px solid #999; background:#fff; cursor:pointer; font-size:16px;
    box-shadow: 0 1px 8px rgba(0,0,0,.04);
  }
  button:disabled{ opacity:.45; cursor:not-allowed; }
  input[type=file]{ font-size:14px; }
  .panel{
    background:#fafafa; border:1px solid var(--border); border-radius:12px; padding:12px; font-size:13px; box-shadow: var(--shadow);
  }
  .kv{ display:grid; grid-template-columns: 190px 1fr; gap:8px 10px; align-items:center; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  input[type=text], select{
    width:100%; padding:9px 10px; border-radius:10px; border:1px solid rgba(0,0,0,.18); font-size:14px; background:#fff;
  }
  .grid{
    display:grid; grid-template-columns: repeat(3, minmax(0, 1fr));
    gap:12px;
  }
  @media (max-width: 950px){ .grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
  @media (max-width: 640px){ .grid{ grid-template-columns: 1fr; } }
  .slot{
    border:1px solid var(--border); border-radius:14px; padding:12px; background:var(--card); box-shadow: var(--shadow);
    display:grid; grid-template-columns: 110px 1fr; gap:10px; align-items:center;
    min-height: 124px;
  }
  .thumb{
    width:110px; height:110px; border-radius:12px; background:#111; object-fit:cover; display:block;
    border:1px solid rgba(255,255,255,.08);
  }
  .slotMeta{ display:flex; flex-direction:column; gap:8px; }
  .slotTop{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .pill{
    font-size:12px; padding:3px 8px; border-radius:999px; border:1px solid rgba(0,0,0,.12); background:#fff;
    white-space:nowrap;
  }
  .pill.seat{ font-weight:700; }
  .pill.empty{ background:#fff; color:var(--muted); }
  label{ font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }
  .tiny{ font-size:12px; color:var(--muted); }
  .hr{ height:1px; background:rgba(0,0,0,.08); margin:10px 0; }
  .linkLine{ font-size:13px; color:var(--muted); }
  .linkLine a{ color:#0a53b0; text-decoration:none; }
  .linkLine a:hover{ text-decoration:underline; }
</style>
</head>
<body>
<main>
  <div class="banner" id="status">‚è≥ waiting‚Ä¶</div>

  <h1 id="title">HiddenRift Airways ‚Äî BoardPass Printer</h1>
  <p class="sub">Snap ‚Üí detect faces (max 6) ‚Üí optionally enter names ‚Üí generate Letter PDF (6 passes per page) ‚Üí upload as the latest.</p>

  <div class="panel">
    <div class="kv">
      <div>Mode</div>
      <div>
        <select id="modeSel">
          <option value="mode1">Mode 1 ‚Äî Mechanical Failure</option>
          <option value="mode2">Mode 2 ‚Äî Bomb</option>
        </select>
        <div class="tiny" id="modeHint" style="margin-top:6px;">Mode 1: add QR values to reach <b>1288</b>.</div>
      </div>

      <div>Cloud Run Base</div><div class="mono" id="baseUrl">‚Äî</div>
      <div>Latest BoardPass PDF</div><div class="linkLine"><a id="latestLink" href="#" target="_blank" rel="noreferrer">‚Äî</a></div>
      <div>Flight / Gate</div><div><span class="mono" id="flightGate">‚Äî</span></div>
      <div>Boarding time</div><div><span class="mono" id="boardingCfg">‚Äî</span></div>
      <div>Target code</div><div><span class="mono" id="loadTargetUi">‚Äî</span> <span class="tiny" id="targetExplain"></span></div>
    </div>
  </div>

  <div id="stage">
    <video id="cam" playsinline muted></video>
    <img id="preview" alt="snapshot preview"/>
  </div>

  <div class="row">
    <button id="start">Start Camera</button>
    <button id="snap" disabled>Snap Photo</button>
    <input type="file" id="file" accept="image/*"/>
    <button id="detect" disabled>Detect Passengers</button>
    <button id="retake" disabled>Retake</button>
  </div>

  <div class="panel">
    <div class="kv">
      <div>Image (w√óh)</div><div><span id="dims" class="mono">‚Äî</span></div>
      <div>Faces found</div><div><span id="faces" class="mono">‚Äî</span></div>
      <div>Seat map</div><div><span class="mono">1A, 1B, 2A, 2B, 3A, 3B</span></div>
      <div>QR</div><div><span>Each ticket includes a <b>LOAD CAPACITY</b> QR that contains only a number.</span></div>
    </div>
  </div>

  <div class="hr"></div>
  <h2>Passengers (max 6)</h2>
  <div class="grid" id="slots"></div>

  <div class="row">
    <button id="make" disabled>Generate BoardPass PDF</button>
  </div>

  <div class="tiny">Tip: most camera/QR apps show the numeric payload large automatically. Use the ticket‚Äôs +/‚àí (Mode 2) for the math.</div>
</main>

<!-- pdf-lib for PDF export -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

<!-- QR generator (reliable) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.4.4/qrcode.min.js"></script>

<script>
/*** CONFIG ***/
const CLOUD_RUN_BASE = "https://alien-face-service-791433334355.us-east4.run.app";
const DETECT_ENDPOINT = CLOUD_RUN_BASE + "/detectFaces";
const UPLOAD_ENDPOINT = CLOUD_RUN_BASE + "/uploadPdfDirect";

const LATEST_BOARDPASS_URL = CLOUD_RUN_BASE + "/boardpass_current";
const TARGET_OBJECT_NAME = "boardpass_current.pdf";

const MAX_PASSES = 6;
const SEATS = ["1A","1B","2A","2B","3A","3B"];

// Branding / content
const AIRLINE_NAME = "HiddenRift Airways";
const FLIGHT_NUM = "HR-876";
const GATE = "RIFT-3";

// Boarding time: NOW - 10 minutes
const BOARDING_MODE = "NOW_PLUS_MIN"; // "NOW_PLUS_MIN" or "FIXED"
const BOARDING_OFFSET_MIN = -10;
const BOARDING_FIXED_TEXT = "6:10 PM";

// Header strip (purplish)
const HEADER_HEX = "#6B2BD1";

// Mode puzzle targets
const MODE1_TARGET = 1288; // Mode 1: plain sum
const MODE2_TARGET = 2386; // Mode 2: signed sum (+ / -)

// Number bounds
const MODE1_MIN = 90;
const MODE1_MAX = 900;

const MODE2_MIN = 90;
const MODE2_MAX = 2500; // supports 1‚Äì6 players hitting 2386 reliably

// Face crop tuning
const FACE_W_MULT = 2.0;
const FACE_H_MULT = 2.2;
const FACE_Y_SHIFT = 0.65;

/*** DOM refs ***/
const statusEl = document.getElementById("status");
const modeSel = document.getElementById("modeSel");
const modeHint = document.getElementById("modeHint");

const baseUrlEl = document.getElementById("baseUrl");
const latestLink = document.getElementById("latestLink");
const flightGateEl = document.getElementById("flightGate");
const boardingCfgEl = document.getElementById("boardingCfg");
const loadTargetUi = document.getElementById("loadTargetUi");
const targetExplain = document.getElementById("targetExplain");

const video = document.getElementById("cam");
const preview = document.getElementById("preview");
const startBtn = document.getElementById("start");
const snapBtn = document.getElementById("snap");
const detectBtn = document.getElementById("detect");
const retakeBtn = document.getElementById("retake");
const fileIn = document.getElementById("file");
const makeBtn = document.getElementById("make");

const dimsEl = document.getElementById("dims");
const facesEl = document.getElementById("faces");
const slotsEl = document.getElementById("slots");

/*** State ***/
let snapshotImg = null;
let snapshotDataUrl = null;
let faceRects = [];
let slots = []; // slots[i] is either null or { seat, name, role, faceCanvas, loadCap, loadOp }

/*** Init UI ***/
baseUrlEl.textContent = CLOUD_RUN_BASE;
latestLink.href = LATEST_BOARDPASS_URL;
latestLink.textContent = LATEST_BOARDPASS_URL;
flightGateEl.textContent = `${FLIGHT_NUM}  |  Gate ${GATE}`;
boardingCfgEl.textContent = (BOARDING_MODE === "NOW_PLUS_MIN")
  ? `Auto: now ${BOARDING_OFFSET_MIN >= 0 ? "+" : "‚àí"} ${Math.abs(BOARDING_OFFSET_MIN)} min`
  : `Fixed: ${BOARDING_FIXED_TEXT}`;

renderEmptySlots();
setBanner("", "‚è≥ Ready. Start camera or choose an image.");
syncModeUi();

/*** Helpers ***/
function setBanner(type, msg){
  statusEl.className = "banner" + (type ? " " + type : "");
  statusEl.textContent = msg;
  console.log("[status]", type, msg);
}
function setDims(w,h){ dimsEl.textContent = `${w}√ó${h}`; }
function setFaces(n){ facesEl.textContent = String(n); }

function stopCamera(){
  const s = video.srcObject;
  if (s && s.getTracks) s.getTracks().forEach(t => t.stop());
  video.srcObject = null;
}

function fmtTime(d){
  return d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" });
}
function getBoardingTimeText(){
  if (BOARDING_MODE === "FIXED") return BOARDING_FIXED_TEXT;
  const d = new Date(Date.now() + BOARDING_OFFSET_MIN * 60 * 1000);
  return fmtTime(d);
}

function blobToBase64(blob){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = () => resolve(String(r.result).split(",")[1]);
    r.onerror = reject;
    r.readAsDataURL(blob);
  });
}

async function imageToBase64NoPrefix(imgEl){
  const c = document.createElement("canvas");
  const w = imgEl.naturalWidth || imgEl.width;
  const h = imgEl.naturalHeight || imgEl.height;
  c.width = w; c.height = h;
  c.getContext("2d").drawImage(imgEl, 0, 0, w, h);
  return c.toDataURL("image/jpeg", 0.95).split(",")[1];
}

function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

function cropFaceToCanvas(imgEl, rect, outW=520, outH=520){
  const imgW = imgEl.naturalWidth || imgEl.width;
  const imgH = imgEl.naturalHeight || imgEl.height;

  const cx = rect.x + rect.w/2;
  const cy = rect.y + rect.h/2;

  const newW = rect.w * FACE_W_MULT;
  const newH = rect.h * FACE_H_MULT;

  let x = Math.floor(cx - newW/2);
  let y = Math.floor(cy - newH * FACE_Y_SHIFT);

  x = clamp(x, 0, imgW - 1);
  y = clamp(y, 0, imgH - 1);

  let w = Math.floor(Math.min(newW, imgW - x));
  let h = Math.floor(Math.min(newH, imgH - y));

  w = Math.max(2, w);
  h = Math.max(2, h);

  const srcAspect = w / h;
  const dstAspect = outW / outH;

  let sx = x, sy = y, sw = w, sh = h;
  if (srcAspect > dstAspect){
    const targetW = Math.floor(h * dstAspect);
    sx = Math.floor(x + (w - targetW)/2);
    sw = targetW;
  } else {
    const targetH = Math.floor(w / dstAspect);
    sy = Math.floor(y + (h - targetH)/2);
    sh = targetH;
  }

  sx = clamp(sx, 0, imgW-1);
  sy = clamp(sy, 0, imgH-1);
  sw = clamp(sw, 2, imgW - sx);
  sh = clamp(sh, 2, imgH - sy);

  const c = document.createElement("canvas");
  c.width = outW; c.height = outH;
  const ctx = c.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(imgEl, sx, sy, sw, sh, 0, 0, outW, outH);
  return c;
}

/*** Mode UI + reseed puzzle values (keeps faces/names) ***/
function getMode(){ return modeSel.value; }

function syncModeUi(){
  const m = getMode();
  if (m === "mode2"){
    loadTargetUi.textContent = String(MODE2_TARGET);
    targetExplain.textContent = "(use +/‚àí on each ticket)";
    modeHint.innerHTML = `Mode 2: use the ticket‚Äôs <b>+ / ‚àí</b> with QR values to reach <b>${MODE2_TARGET}</b>.`;
  } else {
    loadTargetUi.textContent = String(MODE1_TARGET);
    targetExplain.textContent = "(add QR values)";
    modeHint.innerHTML = `Mode 1: add QR values to reach <b>${MODE1_TARGET}</b>.`;
  }
}

function reseedPuzzleForCurrentMode(){
  const n = slots.filter(s => !!s).length;
  if (!n) return;

  const m = getMode();
  if (m === "mode2"){
    const signed = genSignedSum(n, MODE2_TARGET, MODE2_MIN, MODE2_MAX, true);
    let k = 0;
    for (let i=0;i<MAX_PASSES;i++){
      if (!slots[i]) continue;
      slots[i].loadCap = signed[k].value;
      slots[i].loadOp = signed[k].op;
      k++;
    }
  } else {
    const vals = genUniqueSum(n, MODE1_TARGET, MODE1_MIN, MODE1_MAX);
    let k = 0;
    for (let i=0;i<MAX_PASSES;i++){
      if (!slots[i]) continue;
      slots[i].loadCap = vals[k];
      slots[i].loadOp = ""; // no sign shown for Mode 1
      k++;
    }
  }
}

modeSel.addEventListener("change", ()=>{
  syncModeUi();
  reseedPuzzleForCurrentMode();
  renderSlots();
});

/*** Slots UI ***/
function renderEmptySlots(){
  slotsEl.innerHTML = "";
  for (let i=0;i<MAX_PASSES;i++){
    const seat = SEATS[i];
    const div = document.createElement("div");
    div.className = "slot";
    div.innerHTML = `
      <img class="thumb" alt="empty" src="data:image/svg+xml;utf8,
        <svg xmlns='http://www.w3.org/2000/svg' width='110' height='110'>
          <rect width='100%25' height='100%25' fill='%23111'/>
          <text x='50%25' y='52%25' dominant-baseline='middle' text-anchor='middle'
                fill='%23999' font-family='system-ui' font-size='12'>EMPTY</text>
        </svg>"/>
      <div class="slotMeta">
        <div class="slotTop">
          <span class="pill seat">Seat ${seat}</span>
          <span class="pill empty">No face</span>
        </div>
        <div>
          <label>Passenger name</label>
          <input type="text" disabled placeholder="Detect faces first"/>
        </div>
        <div>
          <label>Role (optional)</label>
          <select disabled>
            <option>Passenger</option>
          </select>
        </div>
      </div>
    `;
    slotsEl.appendChild(div);
  }
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

function renderSlots(){
  slotsEl.innerHTML = "";
  const m = getMode();

  for (let i=0;i<MAX_PASSES;i++){
    const seat = SEATS[i];
    const s = slots[i] || null;
    const div = document.createElement("div");
    div.className = "slot";

    const thumbSrc = s ? s.faceCanvas.toDataURL("image/png") : `data:image/svg+xml;utf8,
      <svg xmlns='http://www.w3.org/2000/svg' width='110' height='110'>
        <rect width='100%25' height='100%25' fill='%23111'/>
        <text x='50%25' y='52%25' dominant-baseline='middle' text-anchor='middle'
              fill='%23999' font-family='system-ui' font-size='12'>EMPTY</text>
      </svg>`;

    const lcText = s
      ? (m === "mode2" ? `LC ${s.loadOp}${s.loadCap}` : `LC ${s.loadCap}`)
      : "No face";

    div.innerHTML = `
      <img class="thumb" alt="face" src="${thumbSrc}"/>
      <div class="slotMeta">
        <div class="slotTop">
          <span class="pill seat">Seat ${seat}</span>
          <span class="pill ${s ? "" : "empty"}">${lcText}</span>
        </div>
        <div>
          <label>Passenger name</label>
          <input type="text" data-idx="${i}" class="nameIn"
                 placeholder="${s ? ("PASSENGER " + (i+1)) : "Detect faces first"}"
                 ${s ? "" : "disabled"}
                 value="${s && s.name ? escapeHtml(s.name) : ""}"/>
        </div>
        <div>
          <label>Role (optional)</label>
          <select data-idx="${i}" class="roleSel" ${s ? "" : "disabled"}>
            <option value="Passenger">Passenger</option>
            <option value="Pilot">Pilot</option>
            <option value="Co-Pilot">Co-Pilot</option>
            <option value="Engineer">Engineer</option>
          </select>
        </div>
      </div>
    `;
    slotsEl.appendChild(div);

    if (s && s.role){
      div.querySelector(".roleSel").value = s.role;
    }
  }

  document.querySelectorAll(".nameIn").forEach(inp=>{
    inp.addEventListener("input", (e)=>{
      const idx = parseInt(e.target.getAttribute("data-idx"), 10);
      if (!slots[idx]) return;
      slots[idx].name = e.target.value;
    });
  });
  document.querySelectorAll(".roleSel").forEach(sel=>{
    sel.addEventListener("change", (e)=>{
      const idx = parseInt(e.target.getAttribute("data-idx"), 10);
      if (!slots[idx]) return;
      slots[idx].role = e.target.value;
    });
  });

  makeBtn.disabled = !slots.some(s => !!s);
}

/*** Random helpers + puzzle generators ***/
function randInt(min, max){
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function shuffleInPlace(a){
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random() * (i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// Mode 1: unique values, sum = target
function genUniqueSum(n, total, minVal, maxVal){
  if (n <= 0) return [];
  if (n === 1) return [total];

  if (total < n*minVal) throw new Error("target too small for bounds");
  if (total > n*maxVal) throw new Error("target too large for bounds");

  for (let attempt=0; attempt<1200; attempt++){
    const vals = [];
    const used = new Set();
    let remaining = total;
    let ok = true;

    for (let i=0; i<n-1; i++){
      const left = n - i - 1;
      const minAfter = left * minVal;
      const maxAfter = left * maxVal;

      const vMin = Math.max(minVal, remaining - maxAfter);
      const vMax = Math.min(maxVal, remaining - minAfter);
      if (vMin > vMax){ ok = false; break; }

      let picked = null;
      for (let k=0; k<250; k++){
        const cand = randInt(vMin, vMax);
        if (used.has(cand)) continue;

        if (left === 1){
          const last = remaining - cand;
          if (last < minVal || last > maxVal) continue;
          if (last === cand) continue;
          if (used.has(last)) continue;
        }

        picked = cand;
        break;
      }

      if (picked === null){ ok = false; break; }
      vals.push(picked);
      used.add(picked);
      remaining -= picked;
    }

    if (!ok) continue;

    const last = remaining;
    if (last < minVal || last > maxVal) continue;
    if (used.has(last)) continue;

    vals.push(last);
    if (new Set(vals).size !== n) continue;
    return shuffleInPlace(vals);
  }

  // fallback
  const base = Math.floor(total / n);
  const vals = [];
  let sum = 0;
  for (let i=0;i<n-1;i++){
    vals.push(base + i);
    sum += base + i;
  }
  vals.push(total - sum);
  return shuffleInPlace(vals);
}

// Mode 2: unique values + random +/- ops, signed sum = target
function genSignedSum(n, target, minVal, maxVal, requireBothSigns){
  if (n <= 0) return [];
  if (n === 1){
    // must be "+"
    return [{ op:"+", value: target }];
  }

  for (let attempt=0; attempt<4000; attempt++){
    // pick ops
    const ops = Array.from({length:n}, ()=> (Math.random() < 0.5 ? "+" : "-"));
    if (requireBothSigns){
      const hasPlus = ops.includes("+");
      const hasMinus = ops.includes("-");
      if (!hasPlus || !hasMinus) continue;
    }

    // generate first n-1 values
    const used = new Set();
    const values = [];
    let partial = 0;

    for (let i=0;i<n-1;i++){
      let v = null;
      for (let k=0;k<400;k++){
        const cand = randInt(minVal, maxVal);
        if (used.has(cand)) continue;
        v = cand;
        break;
      }
      if (v === null){ values.length = 0; break; }
      used.add(v);
      values.push(v);
      partial += (ops[i] === "+" ? v : -v);
    }
    if (values.length !== n-1) continue;

    // compute last value needed
    const needed = target - partial;
    const lastOp = ops[n-1];
    const lastVal = (lastOp === "+") ? needed : -needed;

    if (!Number.isFinite(lastVal)) continue;
    if (!Number.isInteger(lastVal)) continue;
    if (lastVal < minVal || lastVal > maxVal) continue;
    if (used.has(lastVal)) continue;

    values.push(lastVal);

    // build list (shuffle together so the +/‚àí feel random per seat)
    const pairs = [];
    for (let i=0;i<n;i++){
      pairs.push({ op: ops[i], value: values[i] });
    }
    return shuffleInPlace(pairs);
  }

  // fallback (no requirement of both signs)
  if (requireBothSigns){
    return genSignedSum(n, target, minVal, maxVal, false);
  }

  // extreme fallback: all plus, unique sum=target
  const vals = genUniqueSum(n, target, minVal, maxVal);
  return vals.map(v => ({ op:"+", value:v }));
}

/*** Camera / file ***/
startBtn.onclick = async () => {
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode:"environment", width:{ideal:1280}, height:{ideal:720} },
      audio:false
    });
    video.srcObject = stream;
    await video.play();

    snapBtn.disabled = false;
    detectBtn.disabled = true;
    retakeBtn.disabled = true;
    makeBtn.disabled = true;

    preview.style.display = "none";
    video.style.display = "block";

    setBanner("", "üé• camera ready ‚Äî line everyone up and snap");
  }catch(e){
    console.error("getUserMedia error", e);
    setBanner("err", "‚ö†Ô∏è Camera blocked. Use HTTPS (GitHub Pages) and allow camera permissions, or use file upload.");
  }
};

snapBtn.onclick = async () => {
  if (!video.srcObject){
    setBanner("warn", "Start camera first (or use file upload).");
    return;
  }
  const c = document.createElement("canvas");
  const W = video.videoWidth;
  const H = video.videoHeight;
  c.width = W; c.height = H;
  c.getContext("2d").drawImage(video, 0, 0, W, H);

  snapshotDataUrl = c.toDataURL("image/jpeg", 0.95);
  preview.src = snapshotDataUrl;

  snapshotImg = new Image();
  snapshotImg.onload = () => setDims(snapshotImg.naturalWidth, snapshotImg.naturalHeight);
  snapshotImg.src = snapshotDataUrl;

  video.style.display = "none";
  preview.style.display = "block";

  detectBtn.disabled = false;
  retakeBtn.disabled = false;
  makeBtn.disabled = true;

  setBanner("", "üì∏ snapshot captured ‚Äî click Detect Passengers");
};

fileIn.onchange = async (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;

  stopCamera();

  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = async () => {
    const c = document.createElement("canvas");
    c.width = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext("2d").drawImage(img, 0, 0);

    snapshotDataUrl = c.toDataURL("image/jpeg", 0.95);
    preview.src = snapshotDataUrl;

    snapshotImg = new Image();
    snapshotImg.onload = () => setDims(snapshotImg.naturalWidth, snapshotImg.naturalHeight);
    snapshotImg.src = snapshotDataUrl;

    video.style.display = "none";
    preview.style.display = "block";

    detectBtn.disabled = false;
    retakeBtn.disabled = false;
    makeBtn.disabled = true;

    setBanner("", "üñºÔ∏è image loaded ‚Äî click Detect Passengers");
  };
  img.src = url;
};

retakeBtn.onclick = () => {
  snapshotImg = null;
  snapshotDataUrl = null;
  faceRects = [];
  slots = [];
  dimsEl.textContent = "‚Äî";
  facesEl.textContent = "‚Äî";
  renderEmptySlots();
  makeBtn.disabled = true;
  detectBtn.disabled = true;
  retakeBtn.disabled = true;

  preview.style.display = "none";
  video.style.display = "block";

  setBanner("", "Retake ready ‚Äî snap a new photo");
};

/*** Face detection ***/
async function detectFacesCloud(imgEl){
  const base64Data = await imageToBase64NoPrefix(imgEl);
  const res = await fetch(DETECT_ENDPOINT, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ imageBase64: base64Data })
  });

  const text = await res.text();
  if (!res.ok){
    console.error("detectFaces error", res.status, text);
    throw new Error("detectFaces failed: " + res.status);
  }

  let json;
  try{ json = JSON.parse(text); }
  catch(e){ throw new Error("bad JSON from /detectFaces"); }

  return (json.faces || []).slice().sort((a,b)=>a.x-b.x);
}

detectBtn.onclick = async () => {
  try{
    if (!snapshotImg){
      setBanner("warn", "Take a photo or choose a file first.");
      return;
    }
    await snapshotImg.decode();

    setBanner("", "üîç detecting faces‚Ä¶");
    faceRects = await detectFacesCloud(snapshotImg);

    if (!faceRects.length){
      setFaces(0);
      slots = [];
      renderEmptySlots();
      makeBtn.disabled = true;
      setBanner("err", "‚ö†Ô∏è 0 faces detected ‚Äî please retake with faces larger, brighter, and centered.");
      return;
    }

    faceRects = faceRects.slice(0, MAX_PASSES);
    const n = faceRects.length;
    setFaces(n);

    // build slots (faces first)
    slots = [];
    for (let i=0;i<MAX_PASSES;i++){
      if (!faceRects[i]) { slots.push(null); continue; }
      const faceCanvas = cropFaceToCanvas(snapshotImg, faceRects[i], 520, 520);
      slots.push({
        seat: SEATS[i],
        name: "",
        role: "Passenger",
        faceCanvas,
        loadCap: 0,
        loadOp: ""
      });
    }

    // assign puzzle values per mode (keeps faces/names)
    reseedPuzzleForCurrentMode();

    renderSlots();
    setBanner("ok", `‚úÖ detected ${n} passenger(s) ‚Äî names optional ‚Äî Generate when ready`);
  }catch(e){
    console.error(e);
    setBanner("err", "‚ö†Ô∏è detection failed ‚Äî retake and try again.");
  }
};

/*** PDF generation helpers ***/
async function canvasToPngBytes(canvas){
  const blob = await new Promise(res => canvas.toBlob(res, "image/png"));
  return await blob.arrayBuffer();
}

async function makeQrPngBytes(payload){
  try{
    if (!window.QRCode || typeof QRCode.toDataURL !== "function") return null;
    const dataUrl = await QRCode.toDataURL(payload, {
      errorCorrectionLevel: "M",
      margin: 1,
      width: 256
    });
    const b64 = dataUrl.split(",")[1];
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }catch(e){
    console.warn("QR generation failed", e);
    return null;
  }
}

function hexToRgb01(hex){
  const h = hex.replace("#","").trim();
  const n = parseInt(h.length === 3 ? h.split("").map(c=>c+c).join("") : h, 16);
  const r = (n >> 16) & 255;
  const g = (n >> 8) & 255;
  const b = n & 255;
  return { r: r/255, g: g/255, b: b/255 };
}

function fitText(font, size, text, maxWidth){
  let t = text;
  while (t.length > 4 && font.widthOfTextAtSize(t, size) > maxWidth){
    t = t.slice(0, -2) + "‚Ä¶";
  }
  return t;
}

/*** PDF generation (layout you approved: bottom-left name/role, bottom-right fields; QR top-right; sign only in Mode 2) ***/
async function buildBoardPassPdfBytes(){
  const { PDFDocument, StandardFonts, rgb } = PDFLib;
  const pdf = await PDFDocument.create();

  const font = await pdf.embedFont(StandardFonts.Helvetica);
  const fontB = await pdf.embedFont(StandardFonts.HelveticaBold);

  const pageW = 612;  // US Letter
  const pageH = 792;
  const page = pdf.addPage([pageW, pageH]);

  // 2 cols x 3 rows = 6 passes per page
  const margin = 24;
  const gapX = 12;
  const gapY = 12;

  const cellW = (pageW - margin*2 - gapX) / 2;
  const cellH = (pageH - margin*2 - gapY*2) / 3;

  page.drawRectangle({ x:0, y:0, width:pageW, height:pageH, color: rgb(1,1,1) });

  const headerRgb = hexToRgb01(HEADER_HEX);
  const headerFill = rgb(headerRgb.r, headerRgb.g, headerRgb.b);
  const white = rgb(1,1,1);
  const black = rgb(0.08,0.08,0.08);
  const gray = rgb(0.35,0.35,0.35);
  const lightLine = rgb(0.86,0.86,0.86);

  const mode = getMode();
  const showSigns = (mode === "mode2");

  for (let i=0;i<MAX_PASSES;i++){
    const s = slots[i];
    if (!s) continue;

    const col = i % 2;
    const row = Math.floor(i / 2);
    const x = margin + col * (cellW + gapX);
    const y = pageH - margin - (row+1) * cellH - row * gapY;

    // ticket border
    page.drawRectangle({
      x, y, width: cellW, height: cellH,
      borderColor: rgb(0.15,0.15,0.15),
      borderWidth: 1,
      color: rgb(1,1,1)
    });

    // header band
    const headerH = 40;
    page.drawRectangle({ x, y: y + cellH - headerH, width: cellW, height: headerH, color: headerFill });

    page.drawText(AIRLINE_NAME.toUpperCase(), {
      x: x + 12,
      y: y + cellH - 26,
      size: 12,
      font: fontB,
      color: white
    });

    const bpText = "BOARDING PASS";
    page.drawText(bpText, {
      x: x + cellW - 12 - fontB.widthOfTextAtSize(bpText, 12),
      y: y + cellH - 26,
      size: 12,
      font: fontB,
      color: white
    });

    // inner box
    const pad = 12;
    const innerX = x + pad;
    const innerY = y + pad;
    const innerW = cellW - pad*2;
    const innerH = cellH - headerH - pad*2;

    // TOP area: photo left, QR right
    const faceSize = 112;
    const qrSize = 92;
    const topRowH = Math.max(faceSize, qrSize);

    const topRowTop = innerY + innerH - topRowH;

    const faceX = innerX;
    const faceY = topRowTop + Math.floor((topRowH - faceSize)/2);

    const qrX = innerX + innerW - qrSize;
    const qrY = topRowTop + Math.floor((topRowH - qrSize)/2);

    // draw photo
    const faceBytes = await canvasToPngBytes(s.faceCanvas);
    const faceImg = await pdf.embedPng(faceBytes);
    page.drawRectangle({ x: faceX - 1, y: faceY - 1, width: faceSize + 2, height: faceSize + 2, borderColor: rgb(0.15,0.15,0.15), borderWidth: 1 });
    page.drawImage(faceImg, { x: faceX, y: faceY, width: faceSize, height: faceSize });

    // draw QR with labels (payload is ONLY number)
    const qrPayload = String(s.loadCap);
    const qrBytes = await makeQrPngBytes(qrPayload);
    if (qrBytes){
      const qr = await pdf.embedPng(qrBytes);

      const label = "LOAD CAPACITY";
      page.drawText(label, {
        x: qrX + (qrSize/2) - (fontB.widthOfTextAtSize(label, 8)/2),
        y: qrY + qrSize + 4,
        size: 8,
        font: fontB,
        color: gray
      });

      page.drawRectangle({ x: qrX - 1, y: qrY - 1, width: qrSize + 2, height: qrSize + 2, borderColor: rgb(0.15,0.15,0.15), borderWidth: 1 });
      page.drawImage(qr, { x: qrX, y: qrY, width: qrSize, height: qrSize });

      const scanTxt = "scan";
      page.drawText(scanTxt, {
        x: qrX + (qrSize/2) - (font.widthOfTextAtSize(scanTxt, 8)/2),
        y: qrY - 10,
        size: 8,
        font,
        color: gray
      });
    }

    // Mode 2 ONLY: big + / ‚àí in the blank space between photo and QR (no overlap)
    if (showSigns){
      const op = (s.loadOp === "-" ? "-" : "+");
      const opSize = 44;
      const gapLeft = faceX + faceSize + 10;
      const gapRight = qrX - 10;
      const gapW = Math.max(10, gapRight - gapLeft);

      // center it in the gap
      const opW = fontB.widthOfTextAtSize(op, opSize);
      const opX = gapLeft + Math.max(0, (gapW - opW) / 2);
      const opY = topRowTop + Math.max(0, (topRowH - opSize) / 2);

      page.drawText(op, {
        x: opX,
        y: opY,
        size: opSize,
        font: fontB,
        color: rgb(0.12,0.12,0.12)
      });
    }

    // divider line BELOW top area
    const dividerY = topRowTop - 10;
    page.drawRectangle({ x: innerX, y: dividerY, width: innerW, height: 1, borderColor: lightLine, borderWidth: 1 });

    // BOTTOM area: left = passenger name + role, right = flight/gate/board/seat
    const bottomTop = dividerY - 14;
    const bottomLeftX = innerX;
    const bottomRightX = innerX + Math.floor(innerW * 0.52) + 10;
    const bottomLeftW = bottomRightX - 10 - bottomLeftX;

    const passengerName = (s.name && s.name.trim()) ? s.name.trim() : `PASSENGER ${i+1}`;
    const role = (s.role || "Passenger").toUpperCase();

    // Left side (name + role)
    const nameSize = 14;
    const roleSize = 10;

    const nameText = fitText(fontB, nameSize, passengerName.toUpperCase(), bottomLeftW);
    page.drawText(nameText, {
      x: bottomLeftX,
      y: bottomTop,
      size: nameSize,
      font: fontB,
      color: black
    });

    const roleText = fitText(font, roleSize, role, bottomLeftW);
    page.drawText(roleText, {
      x: bottomLeftX,
      y: bottomTop - 16,
      size: roleSize,
      font,
      color: gray
    });

    // Right side fields
    const keySize = 9;
    const valSize = 11;
    const lineH = 13;

    const keyX = bottomRightX;
    const valX = bottomRightX + 52;
    const maxValW = Math.max(40, (innerX + innerW) - valX);

    let yy = bottomTop;

    const field = (k, v) => {
      page.drawText(k, { x: keyX, y: yy, size: keySize, font, color: gray });
      const vv = fitText(fontB, valSize, v, maxValW);
      page.drawText(vv, { x: valX, y: yy, size: valSize, font: fontB, color: black });
      yy -= lineH;
    };

    const boardingTime = (BOARDING_MODE === "FIXED") ? BOARDING_FIXED_TEXT : getBoardingTimeText();
    const seat = s.seat || SEATS[i];

    field("FLIGHT", FLIGHT_NUM);
    field("GATE", GATE);
    field("BOARD", boardingTime);
    field("SEAT", seat);
  }

  return await pdf.save();
}

/*** Upload ***/
async function uploadPdfDirectToCloudRun(pdfBlob){
  setBanner("", "‚òÅ uploading boardpass_current.pdf‚Ä¶");
  const pdfBase64 = await blobToBase64(pdfBlob);

  const res = await fetch(UPLOAD_ENDPOINT, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({
      pdfBase64,
      objectName: TARGET_OBJECT_NAME
    })
  });

  const txt = await res.text();
  console.log("[upload] response", res.status, txt);

  if (!res.ok){
    throw new Error("upload failed: " + res.status + " " + txt);
  }
  setBanner("ok", "‚úÖ Uploaded. Latest BoardPass PDF is live at the link above.");
}

/*** Main generate ***/
makeBtn.onclick = async () => {
  try{
    if (!slots.some(s => !!s)){
      setBanner("warn", "No passengers detected yet. Click Detect Passengers first.");
      return;
    }

    setBanner("", "üßæ building PDF‚Ä¶");
    const pdfBytes = await buildBoardPassPdfBytes();
    const blob = new Blob([pdfBytes], { type:"application/pdf" });

    await uploadPdfDirectToCloudRun(blob);

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "boardpass_current.pdf";
    a.click();

    try{ window.open(a.href, "_blank", "noopener,noreferrer"); }catch(e){}
  }catch(e){
    console.error(e);
    setBanner("err", "‚ö†Ô∏è Failed to generate/upload PDF. " + (e.message || ""));
  }
};
</script>
</body>
</html>
